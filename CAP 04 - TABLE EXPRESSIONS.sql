/*

----------------- TABLE EXPRESSIONS -----------------

SÃO TABELAS VIRTUAIS CRIADAS ATRAVÉS DE QUERIES NO BANCO DE DADOS.

NÃO POSSUEM ARMAZENAMENTO FÍSICO, POR ISSO, APRESENTAM UMA PERFORMANCE LIGEIRAMENTE MELHOR.

SÃO UM EXCELENTE RECURSO PARA DESENVOLVIMENTO DE SOLUÇÕES COM SQL

QUANDO UMA CONSULTA ENVOLVENDO UMA EXPRESSÃO DE TAELA É CONCLUÍDA, A TABELA DESPARECE

EXISTEM 4 TIPOS: VIEWS, CTES, TABLE-VALUED FUNCTION (TVF) E DERIVED TABLES

O RESULTADO DA QUERY INTERNA NÃO É PERSISTIDO EM NENHUM LUGAR, É APENAS ALINHADO.
*/

-- TABELAS DERIVADAS OU TABLES SUBQUERIES

-- SÃO CRIADAS NA CLÁUSULA FROM DA QUERY EXTERNA
-- SÃO DEPENDENTES DA QUERY EXTERNA 
-- QUANDO A QUERY É FINALIZADA, ELA DESAPARECE.
-- A ORDEM NA QUERY INTERNA NÃO É GARANTIDA; REGRA DE TODA QUERY EM BANCO DE DADOS
-- PELO MOTIVO ACIMA, ORDER BY NÃO É PERMITIDO NA QUERY INTERNA
-- TODAS AS COLUNAS DEVEM TER NOMES
-- DEVEM SER ÚNICAS

SELECT -- TODAS AS COLUNAS DESSA QUERY SÃO ORIUNDAS DA QUERY INTERNA
    BUSINESSENTITYID,
    LOGINID, BIRTHDATE
FROM (
    SELECT TOP(100)
        BUSINESSENTITYID,
        LOGINID,  BIRTHDATE
    FROM HumanResources.Employee
) AS EMP
WHERE EMP.BusinessEntityID IS NOT NULL;

SELECT  -- IMG02
    BUSINESSENTITYID, 
    LOGINID, BIRTHDATE
FROM (
    SELECT
        BUSINESSENTITYID,
        LOGINID, BIRTHDATE
    FROM HumanResources.Employee
    ORDER BY BusinessEntityID DESC
) AS EMP_INFO
WHERE EMP_INFO.BusinessEntityID IS NOT NULL;

SELECT *
    FROM(
        SELECT TOP (10)
            T1.DepartmentID, T1.[NAME] AS DEPART_NAME,
            T2.BusinessEntityID, T2.StartDate,
            T2.EndDate
        FROM HumanResources.Department AS T1
            INNER JOIN
            HumanResources.EmployeeDepartmentHistory AS T2
        ON T1.DepartmentID = T2.DepartmentID
    ) AS DEPART_INFO;

/* 
COMO A QUERY EXTERNA CONSULTA A QUERY INTERNA PARA OBTER RESULTADO
PODEMOS ATRIBUIR NOMES PARA AS COLUNAS E CONSULTAR POR ELES NA QUERY EXTERNA
*/

SELECT 
    ORDERYEAR,
    COALESCE(COUNT(SalesPersonID), 0) AS SALESPERSON
FROM(
    SELECT
        YEAR(ORDERDATE) AS ORDERYEAR,
        SALESPERSONID
    FROM Sales.SalesOrderHeader
) AS SALES_BY_PERSON
GROUP BY ORDERYEAR
HAVING ORDERYEAR BETWEEN 2011 AND 2013;


/*
COMO O NOME É TABLE EXPRESSION, BASICAMENTE CRIEI UMA EXPRESSÃO DE UMA CONSULTA QUE RETORNA ALGUNS DADOS.
TODA A ESTRUTURA ESTA NA QUERY INTERNA E AO FINAL, É POSSÍVEL UNIR COM A QUERY EXTERNA ADICIONANDO OUTRAS TABELAS
NO JOIN.
*/

/*
O PROBLEMA DAS TABELAS DERIVADAS É QUE A MEDIDA QUE VAMOS ADICINANDO MAIS CONSULTAS INTERNAS, O DEBUG FICA IMPRATICÁVEL
OUTRO PROBLEMA DESSE TIPO DE CONSTRUÇÃO É O ANINHAMENTO, QUE TORNA O CÓDIGO CONFUSO E QUASE ILEGÍVEL.
ESSE TIPO DE ESTRUTURA DIFICULDA A PERCEPÇÃO DO QUE ESTÁ SENDO EXECUTADO NA QUERY
*/

SELECT -- IMG 05
    T2.BusinessEntityID, T2.FirstName,
    T2.LastName, JobTitle,
    DepartmentID, DEPARTNAME
FROM (
    SELECT
        T1.BUSINESSENTITYID, JOBTITLE,
        T2.DEPARTMENTID, T3.[NAME] AS DEPARTNAME
    FROM HumanResources.Employee AS T1
        INNER JOIN
         HumanResources.EmployeeDepartmentHistory AS T2
        ON T1.BusinessEntityID = T2.BusinessEntityID
        INNER JOIN 
        HumanResources.Department AS T3
        ON T2.DepartmentID = T3.DepartmentID
    WHERE T1.BusinessEntityID IS NOT NULL
) AS EMPINFO
INNER JOIN
Person.Person AS T2
ON EMPINFO.BusinessEntityID = T2.BusinessEntityID
WHERE EMPINFO.BusinessEntityID IS NOT NULL;

SELECT
    ORDERYEAR,
    TOTALYEAR
FROM (
    SELECT
        YEAR(ORDERDATE) AS ORDERYEAR,
        SUM(SUBTOTAL) AS TOTALYEAR
    FROM Sales.SalesOrderHeader
    GROUP BY YEAR(OrderDate)
) AS TOTALBYYEAR
WHERE ORDERYEAR BETWEEN 2011 AND 2013;


SELECT
    CUR.ORDERYEAR, CUR.NUMORDERS, CUR.NUMORDERS - PRV.NUMORDERS AS DIFF
FROM (
    SELECT
        YEAR(ORDERDATE) AS ORDERYEAR, COUNT(*) NUMORDERS
    FROM Sales.SalesOrderHeader
    GROUP BY YEAR(ORDERDATE)) AS CUR
LEFT JOIN
    (SELECT
        YEAR(ORDERDATE) AS ORDERYEAR, COUNT(*) AS NUMORDERS
    FROM Sales.SalesOrderHeader 
    GROUP BY YEAR(ORDERDATE)) AS PRV
ON CUR.ORDERYEAR = PRV.ORDERYEAR + 1

SELECT
    CUR.NUMORDERS, CUR.ORDERYEAR, (CUR.NUMORDERS - PRV.NUMORDERS) AS DIFFORDER
FROM (
    SELECT
        YEAR(ORDERDATE) AS ORDERYEAR, COUNT(SalesOrderID) AS NUMORDERS
    FROM Sales.SalesOrderHeader 
    GROUP BY YEAR(ORDERDATE)) AS CUR
LEFT JOIN(
    SELECT
        YEAR(ORDERDATE) AS ORDERYEAR, COUNT(SALESORDERID) AS NUMORDERS
    FROM Sales.SalesOrderHeader
    GROUP BY YEAR(ORDERDATE)) AS PRV
ON CUR.ORDERYEAR = PRV.ORDERYEAR + 1
ORDER BY ORDERYEAR;

-- O POSITIVO DESSE TIPO DE ESTRUTURA É QUE AO SER FINALIZADA, A QUERY "SOME". COMO ELA NÃO É FISICAMENTE PERSISTIDA, NÃO É MANTIDA PELO BANCO
-- TODA A EXISTENCIA É GARANTIDA PELA QUERY EXTERNA. SEMPRE

SELECT
    BusinessEntityID, FirstName,
    LastName, JobTitle,
    HireDate
FROM (
    SELECT TOP (100)
        T1.BusinessEntityID, FIRSTNAME,
        LASTNAME, JOBTITLE,
        HIREDATE
    FROM Person.Person AS T1
        INNER JOIN
        HumanResources.Employee AS T2
    ON T1.BusinessEntityID = T2.BusinessEntityID
    ORDER BY HireDate) AS EMP_INFO
WHERE HireDate >= '20070101' AND HireDate < '20081231';

-- UTILIZANDO PARÂMETROS

SELECT 
    BUSINESSENTITYID
FROM HumanResources.Employee AS T1
WHERE BusinessEntityID IN (SELECT
                            SalesPersonID
                            FROM Sales.SalesOrderHeader AS T2
                            WHERE T1.BusinessEntityID = T2.SalesPersonID)

DECLARE @EMPLID AS INT = 278
DECLARE @YEARDATE AS INT = '2011'

SELECT
    ORDERDATE, ORDERNUM
FROM (
    SELECT
        YEAR(ORDERDATE) AS ORDERDATE,
        COUNT(SALESORDERID) AS ORDERNUM
    FROM Sales.SalesOrderHeader 
    GROUP BY YEAR(ORDERDATE), SalesPersonID
    HAVING SalesPersonID = @EMPLID
) AS COUNTORDER
WHERE ORDERDATE >= 2011

/*
NÃO EXISTE UMA RESTRIÇÃO DE USO. TABLE EXPRESSION NÃO CAUSA UMA DIFERENÇA GRANDE NA PERFORMANCE GERAL DA QUERY.
QUERIES NORMAIS, COM A MESMA ESTRUTURA, PORÉM MAIOR, TERIAM O MESMO IMPACTO E O MESMO CUSTO PARA O BANCO; DE UMA FORMA GERAL.
*/

-------------------------------------- CTE --------------------------------------

-- /*

-- CTE É UM RECURSO QUE A LINGUAGEM SQL POSSUI PARA CRIAR TABELAS VIRTUAIS ATRAVÉS DE QUERIES.
-- ESSAS TABELAS SÃO CRIADAS QUANDOA QUERY É EXECUTADA E AO FINAL, SÃO DESFEITAS.
-- A VANTAGEM DA CTE É CONSULTAR ATRAVÉS DE UMA QUERY EXTERNA, GERALMENTE MAIS SIMPLES, UMA QUERY INTERNA, QUE COSTUMA SER MAIS COMPLEXA
-- OUTRO PONTO POSITIVO É A FACILIDADE QUE ELA PROPORCIONA PARA SOLUCIONAR QUERIES MAIS COMPLEXAS. COMO PODEMOS "QUEBRAR" EM QUERIES MENORES,
-- DIVIDIMOS O TRABALHO ATÉ CHEGAR AO RESULTADO FINAL DESEJADO, COM MAIOR FACILIDADE.

-- */

-- -- AO TRABALHAR COM CTE, O BLOCO INTEIRO DEVE SER EXECUTADO DE UMA ÚNICA VEZ.
-- -- PERCEBA QUE ESTOU CONSULTANDO A QUERY DA CTE CHAMADA "USA CUSTS"
-- -- É POSSÍVEL REFENCIAR A MESMA TABELA DIVERSAS VEZES NA MESMA QUERY, DANDO MAIS CLAREZA E FACILIDADE DE LEITURA PARA O CÓDIGO
-- -- A PERFORMANCE DA CTE COSTUMA SER MUITO BOA, O QUE A TORNA UM RECURSO EXTREMAMENTE ÚTIL PARA USO E DOMÍNIO

WITH EMPLOYEE_INFO AS (     
    
    SELECT
        T1.BUSINESSENTITYID, FIRSTNAME, LASTNAME, JOBTITLE,
        GENDER, T4.DEPARTMENTID, [NAME] AS DEPART_NAME, GROUPNAME
    FROM Person.Person AS T1
    INNER JOIN
        HumanResources.Employee AS T2
    ON T1.BusinessEntityID = T2.BusinessEntityID
    LEFT JOIN
        HumanResources.EmployeeDepartmentHistory AS T3
    ON T2.BusinessEntityID = T3.BusinessEntityID
    LEFT JOIN
        HumanResources.Department AS T4
    ON T3.DepartmentID = T4.DepartmentID)
SELECT
    BusinessEntityID, FirstName, LastName,
    JobTitle, DEPART_NAME, GroupName
FROM EMPLOYEE_INFO
WHERE DEPART_NAME LIKE 'SALES%';

-- SE DESEJA UTILIZAR ARGUMENTOS EM UMA CTE, ELE DEVE VIR NA QUERY INTERNA.
-- LEMBRE-SE QUE É ELA QUEM EXECUTA A BUSCA NO BANCO

DECLARE @SALESPID AS INT = 288; --(IMG07)

WITH QTD_SALES_BY_EMP AS (

    SELECT
        COUNT(SALESORDERID) AS ORDERID,
        SALESPERSONID,
        YEAR(ORDERDATE) AS ORDERDATE
    FROM Sales.SalesOrderHeader
    GROUP BY SalesPersonID, YEAR(OrderDate)
    HAVING SALESPERSONID = @SALESPID
)
SELECT 
    ORDERID, SALESPERSONID, ORDERDATE
FROM QTD_SALES_BY_EMP;

-- DIFERENTE DO QUE ACONTECE COM AS DERIVED TABLES, NÃO PRECIAMOS ANINHAR AS DIVERSAS CTE'S TORNANDO O CÓDIGO COMPLICADO.
-- COM AS CTE'S, PODEMOS DIVIDIR DIVERSAS ESTRUTURAS REFERENCIADO UMA NA OUTRA.

WITH SALES_PER_CUST AS (

    SELECT
        SALESORDERID, CUSTOMERID,
        SUBTOTAL, ORDERDATE
    FROM Sales.SalesOrderHeader
),
SUM_PER_CUST AS(
    
    SELECT
        COUNT(SALESORDERID) AS ORDER_PER_CUST,
        CUSTOMERID, YEAR(ORDERDATE) AS YEAR_ORDER
        --SUM(SUBTOTAL) TOTAL_PER_CUST,
    FROM SALES_PER_CUST
    GROUP BY CustomerID, YEAR(ORDERDATE)
)
SELECT * FROM SUM_PER_CUST
WHERE ORDER_PER_CUST > 10;

-- UM OUTRO TIPO DE USO PARA MÚLTIPLAS CTE's 
-- ESSA É UMA FORMA DE DEIXAR QUERIES PRÉ PRONTAS E UNIR QUANDO DESEJAR NA QUERY FINAL.
WITH DEPART_EMPLOYE AS (

    SELECT
        T1.DEPARTMENTID, [NAME] AS DEPART_NAME,
        T2.BusinessEntityID
    FROM HumanResources.Department AS T1
        INNER JOIN
        HumanResources.EmployeeDepartmentHistory AS T2
    ON T1.DepartmentID = T2.DepartmentID
),
PERSON_EMPLOYEE AS (
    SELECT
        T1.BUSINESSENTITYID, FIRSTNAME,
        LASTNAME, JOBTITLE
    FROM Person.Person AS T1
        INNER JOIN
        HumanResources.Employee AS T2
    ON T1.BusinessEntityID = T2.BusinessEntityID
)

SELECT T1.BUSINESSENTITYID, FIRSTNAME, LASTNAME, JOBTITLE, DEPART_NAME
FROM PERSON_EMPLOYEE AS T1
    INNER JOIN
    DEPART_EMPLOYE AS T2
ON T1.BusinessEntityID = T2.BusinessEntityID;


-- JOIN ENTRE DUAS CTE

WITH TOTAL_BY_CUST AS (

    SELECT
        CUSTOMERID,
        YEAR(ORDERDATE) AS ORDERYEAR,
        SUM(SUBTOTAL) AS TOTAL_REVENUE
    FROM Sales.SalesOrderHeader 
    GROUP BY CustomerID, YEAR(ORDERDATE)

),
CUST_INFO AS (
    
    SELECT
        CUSTOMERID, PERSONID,
        T1.FIRSTNAME,T1.LASTNAME
    FROM Person.[Person] AS T1
        INNER JOIN
        Sales.Customer AS T2
    ON T1.BusinessEntityID = T2.PersonID
)

SELECT
    T1.CUSTOMERID, FIRSTNAME, 
    LASTNAME, ORDERYEAR, TOTAL_REVENUE
FROM CUST_INFO AS T1
    INNER JOIN
     TOTAL_BY_CUST AS T2
ON T1.CustomerID = T2.CustomerID
ORDER BY T1.CustomerID, ORDERYEAR;

WITH YEARLY_COUNT AS (

    SELECT
        YEAR(ORDERDATE) AS ORDERYEAR,
        COUNT(DISTINCT(CUSTOMERID)) AS NUMCUST
    FROM Sales.SalesOrderHeader
    GROUP BY YEAR(ORDERDATE)
)
SELECT 
    CUR.NUMCUST AS CUR_NUMCUST, COALESCE(PRV.NUMCUST, 0) AS PRV_NUMCUST,
    COALESCE(CUR.NUMCUST - PRV.NUMCUST, 0) AS CUST_GROWTH, CUR.ORDERYEAR
FROM YEARLY_COUNT AS CUR
    LEFT JOIN
    YEARLY_COUNT AS PRV
ON CUR.ORDERYEAR = PRV.ORDERYEAR + 1
ORDER BY ORDERYEAR;

-- CTE RECURSIVA SÃO PADRÕES DO SQL
-- SÃO NO MÍNIMO DUAS QUERIES PARA CRIAR A ESTRUTURA
-- UMA É CONHECIDA COM A QUERY ANCORA E A OUTRA A RECURSIVA
-- A QUERY ANCORA É QUEM RETORNA O RESULTADO E É CHAMADA APENAS 1X
-- A QUERY RECURSIVA É QUEM REFERENCIA A CTE E É EXECUTADA ATÉ RETORNAR VAZIO

USE TSQLV4;

WITH EMPCTE AS (

    SELECT
        EMPID, MGRID, 
        FIRSTNAME, LASTNAME
    FROM HR.Employees
    WHERE empid = 2

    UNION ALL

    SELECT 
        C.EMPID, C.MGRID,
        C.FIRSTNAME, C.LASTNAME
    FROM EMPCTE AS P
        INNER JOIN
        HR.Employees AS C
    ON C.mgrid = P.empid
)
SELECT EMPID, MGRID, FIRSTNAME, LASTNAME
FROM EMPCTE;

USE AdventureWorks2019;
WITH REC_EMP AS (

    SELECT 
        BUSINESSENTITYID, JOBTITLE, ORGANIZATIONLEVEL
    FROM [HumanResources].[Employee]
    WHERE BusinessEntityID = 100

    UNION ALL

    SELECT 
        T1.BUSINESSENTITYID, T1.JOBTITLE, T1.OrganizationLevel
    FROM REC_EMP AS T1
        INNER JOIN
        Person.Person AS T2
    ON T1.OrganizationLevel = T2.BusinessEntityID
)
SELECT * FROM REC_EMP;

WITH SALES_YEAR AS(

    SELECT
        CUSTOMERID, SALESORDERID, YEAR(ORDERDATE) AS ORDERYEAR
    FROM Sales.SalesOrderHeader
    WHERE SalesOrderID = 43660

    UNION ALL

    SELECT T1.CUSTOMERID, SALESORDERID, ORDERYEAR
    FROM SALES_YEAR AS T1
        INNER JOIN
        Sales.Customer AS T2
    ON T1.SalesOrderID = T2.CustomerID
)
SELECT * FROM SALES_YEAR;


WITH EMP_INFO AS(

    SELECT
        BUSINESSENTITYID, 
        JOBTITLE, ORGANIZATIONLEVEL
    FROM HumanResources.Employee

    UNION ALL

    SELECT
        T1.BUSINESSENTITYID,
        T1.JOBTITLE, T1.ORGANIZATIONLEVEL
    FROM EMP_INFO AS T1
        JOIN
        HumanResources.Employee AS T2
    ON T1.BusinessEntityID = T2.OrganizationLevel
)
SELECT
    BUSINESSENTITYID,
    JOBTITLE, ORGANIZATIONLEVEL
FROM EMP_INFO;

                    ------------------- VIEWS -------------------

-- OBJETOS MATERIALIZADOS NO BANCO, MAS QUE NÃO OCUPAM ESPAÇO FÍSICO - SALVO VIEWS INDEXADAS
-- NÃO SÃO FINALIZADAS AO FINAL DA QUERY, PODEM SER CONSULTADAS A QUALQUER MOMENTO
-- OTIMAS PARA PROTEGER O ACESSO A DADOS CONFIDENCIAIS 
-- VIEWS NÃO ACEITAM PARÂMETROS DE INPUT
-- MUDANÇA ESTRUTURAL NA TABELA FONTE A VIEW NÃO CAPTURA
-- UPDATES NA TABELA A VIEW CAPTURA
-- QUANDO ALTERAR A ESTRUTURA DA TABELA, UTILIZE A PROCEDURE SP_REFRESHVIEW.

IF OBJECT_ID (N'VIEW_EXAMPLE') IS NOT NULL DROP VIEW VIEW_EXAMPLE; -- IMG 11
GO
CREATE VIEW VIEW_EXAMPLE
AS
SELECT * FROM HumanResources.Department;
GO

SELECT * FROM VIEW_EXAMPLE;


IF OBJECT_ID (N'SALES.YEAR_SALES', N'V') IS NOT NULL DROP VIEW SALES.YEAR_SALES;
GO
CREATE VIEW SALES.YEAR_SALES WITH SCHEMABINDING AS -- IMG12
-- SCHEMABINDING BLOQUEIA QUALQUER MUDANÇA NA ESTRUTURA DA VIEW

SELECT
    YEAR(ORDERDATE) AS ORDERYEAR,
    PRODUCTID,
    SUM(SUBTOTAL) AS TOTAL_PRODUCT
FROM Sales.SalesOrderHeader AS T1
    LEFT JOIN
    Sales.SalesOrderDetail AS T2
ON T1.SalesOrderID = T2.SalesOrderID
GROUP BY YEAR(ORDERDATE), PRODUCTID;
GO

SELECT * FROM Sales.YEAR_SALES
ORDER BY ProductID;
GO

BEGIN TRAN 
ALTER TABLE SALES.SALESORDERDETAIL
DROP COLUMN ORDERQTY
ROLLBACK;
GO

IF OBJECT_ID('OPT_VIEW', N'V') IS NOT NULL DROP VIEW OPT_VIEW;
GO

CREATE VIEW OPT_VIEW AS

SELECT BusinessEntityID, FirstName, LastName 
FROM PERSON.PERSON
WHERE BusinessEntityID IN (
                            SELECT
                            BusinessEntityID
                            FROM HumanResources.Employee)
WITH CHECK OPTION;
GO

SELECT * FROM OPT_VIEW
WHERE BusinessEntityID NOT IN (
                        SELECT BusinessEntityID 
                        FROM HumanResources.Employee);
GO


DROP VIEW IF EXISTS SALES.CUSTOMER_ORDER;
GO

CREATE VIEW SALES.CUSTOMER_ORDER AS

    SELECT 
        T2.CUSTOMERID,
        T1.FIRSTNAME,
        T1.LASTNAME,
        SUM(SUBTOTAL) AS TOTAL_CUSTOMER,
        COUNT(SALESORDERID) AS ORDER_BY_CUST
    FROM SALES.CUSTOMER AS T2
        INNER JOIN
        PERSON.PERSON AS T1
    ON T1.BUSINESSENTITYID = T2.PERSONID
        INNER JOIN
        Sales.SalesOrderHeader AS T3
    ON T2.CustomerID = T3.CustomerID
    GROUP BY T2.CUSTOMERID, FirstName, LastName
GO

SELECT * FROM SALES.CUSTOMER_ORDER
WHERE CustomerID = 29947;

-- COMO ATUALIZAR VIEWS

DROP TABLE IF EXISTS  DBO.TESTEVIEW;
GO
CREATE TABLE DBO.TESTEVIEW(

    ID INT NOT NULL IDENTITY,
    COL2 VARCHAR(10) NOT NULL
);
GO

INSERT INTO DBO.TESTEVIEW (COL2)
VALUES('TESTE_VIEW');
GO 10

SELECT * FROM DBO.TESTEVIEW;
GO

DROP VIEW IF EXISTS DBO.VIEW_TESTE;
GO

CREATE VIEW DBO.VIEW_TESTE AS

    SELECT * FROM DBO.TESTEVIEW;
GO

SELECT * FROM DBO.VIEW_TESTE;

ALTER TABLE DBO.TESTEVIEW 
ADD COL4 VARCHAR(10);
GO

SELECT * FROM DBO.VIEW_TESTE;

EXEC sp_refreshview VIEW_TESTE;

UPDATE DBO.TESTEVIEW
SET COL3 = COL2
WHERE COL3 IS NULL;
GO

-- VIEWS AND ORDER BY
-- -POR NATUREZA, VIEWS NÃO PODEM GARANTIR A ORDEM DO RESULTADO, MESMO FORÇADO

DROP VIEW IF EXISTS ORDER_VIEW;
GO

CREATE VIEW DBO.ORDER_VIEW AS 

    SELECT TOP(100) PERCENT
        COUNT(SALESORDERID) AS TOTALORDER,
        SUM(SUBTOTAL) AS TOTAL,
        TERRITORYID
    FROM SALES.SALESORDERHEADER
    GROUP BY TERRITORYID;
GO

SELECT * FROM DBO.ORDER_VIEW
ORDER BY TOTAL;
GO

-- TOP E ORDER BY NA CONSTRUÇÃO DA VIEW
-- A ORDEM NÃO É GARANTIDA
ALTER VIEW DBO.ORDER_VIEW AS 

    SELECT TOP(100) PERCENT
        COUNT(SALESORDERID) AS TOTALORDER,
        SUM(SUBTOTAL) AS TOTAL,
        TERRITORYID
    FROM SALES.SALESORDERHEADER
    GROUP BY TERRITORYID
    ORDER BY TerritoryID;
GO

SELECT 
    TerritoryID,
    CAST(TOTAL AS decimal(12,2)) AS TOTAL,
    TOTALORDER
FROM DBO.ORDER_VIEW
ORDER BY TerritoryID;

-- SEGURANÇA EM VIEWS

-- CRIANDO VIEW DE EXEMPLO (IMG16)
IF OBJECT_ID('HUMANRESOURCES.EMP_VIEW', N'V') IS NOT NULL DROP VIEW HumanResources.EMP_VIEW;
GO

CREATE VIEW HUMANRESOURCES.EMP_VIEW AS

    SELECT
    T1.BUSINESSENTITYID, T1.FIRSTNAME, T1.LASTNAME,
    T2.ORGANIZATIONLEVEL, T2.JOBTITLE, T2.HIREDATE
FROM PERSON.Person AS T1
    INNER JOIN
    HumanResources.Employee AS T2
ON T1.BusinessEntityID = T2.BusinessEntityID;
GO

-- EXIBE A QUERY UTILIZADA PARA CRIAR A VIEW. (IMG17)
SELECT OBJECT_DEFINITION(OBJECT_ID('HUMANRESOURCES.EMP_VIEW')) AS EMP_VIEW_QUERY; 

-- VIEWS ENCRYPTADAS

-- SÃO VIEWS CRIADAS COM A OPÇÃO WITH ENCRYPTION


DROP VIEW IF EXISTS SALES.TOP_CUSTOMER;
GO

CREATE VIEW SALES.TOP_CUSTOMER WITH ENCRYPTION 
AS 
    SELECT 
    T1.CUSTOMERID, T2.FIRSTNAME, T2.LASTNAME,
    COUNT(T3.SALESORDERID) AS TOTAL_ORDER,
    COALESCE(T3.SALESPERSONID, 0) AS SALESPERSON,
    SUM(TOTALDUE) AS TOTAL_SALES
FROM Sales.Customer AS T1
    INNER JOIN
    Person.Person AS T2
ON T1.PersonID = T2.BusinessEntityID
    INNER JOIN
    Sales.SalesOrderHeader AS T3
ON T1.CustomerID = T3.CustomerID
GROUP BY T1.CUSTOMERID, SALESPERSONID, FIRSTNAME, LASTNAME
HAVING COUNT(SalesOrderID) >= 10;
GO

SELECT OBJECT_DEFINITION(OBJECT_ID('SALES.TOP_CUSTOMER')) AS QUERY_TOP_CUSTOMER; -- QUERY RETORNA NULL, NÃO VEMOS A QUERY QUE CRIOU

EXEC sp_helptext 'SALES.TOP_CUSTOMER'  -- QUERY RETORNA QUE A VIEW FOI CRIPTOGRAFADA.


----------- TABLE VALUED FUNCTION ----------

-- RECURSO ALTERNATIVO AO USO DE VIEWS, UMA VEZ QUE PERMITE UTILIZAR PARÂMETROS
-- ESSES PARÂMETROS FUNCIONAM COMO UM INPUT, ISSO QUER DIZER QUE PODEMOS PASSAR VALORES
-- PODEMOS DIZER QUE SÃO VIEWS PARAMTRIZADAS

IF OBJECT_ID('SALES.SALESPERSON_YEAR') IS NOT NULL DROP FUNCTION SALES.SALESPERSON_YEAR;
GO
CREATE FUNCTION SALES.SALESPERSON_YEAR
    (@YEAR AS INT) RETURNS TABLE

AS
RETURN
    SELECT
        COALESCE(SALESPERSONID, 0) AS SALESPERSON, COUNT(SALESORDERID) AS ORDER_DUE,
        SUM(TOTALDUE) AS TOTAL_SALES, YEAR(ORDERDATE) AS ORDER_YEAR
    FROM Sales.SalesOrderHeader
    GROUP BY SalesPersonID, YEAR(ORDERDATE)
    HAVING YEAR(ORDERDATE) = @YEAR;
GO

SELECT * FROM Sales.SALESPERSON_YEAR(2012);

IF OBJECT_ID('SALES.TOP_PRODUCTS') IS NOT NULL DROP FUNCTION SALES.TOP_PRODUCTS;
GO

CREATE FUNCTION SALES.TOP_PRODUCTS
    (@PRODID AS INT) RETURNS TABLE
AS 
RETURN
    SELECT
        PRODUCTID, 
        SUM(OrderQty) QUANTITY,
        YEAR(T2.ORDERDATE) AS ORDERYEAR,
        SUM(TotalDue) AS TOTAL_BY_PROD,
        AVG(TOTALDUE) AS AVG_BY_PROD
    FROM Sales.SalesOrderDetail AS T1
    INNER JOIN
        Sales.SalesOrderHeader AS T2
    ON T1.SalesOrderID = T2.SalesOrderID
    GROUP BY YEAR(ORDERDATE), PRODUCTID
    HAVING ProductID = @PRODID;
GO

SELECT * FROM Sales.TOP_PRODUCTS(736);
GO

DROP FUNCTION IF EXISTS SALES.RUNNING_QTY;
GO

CREATE FUNCTION SALES.RUNNIG_QTY
    (@PRODID AS INT) RETURNS TABLE
AS 
    RETURN
        --SELE
SELECT 
    PRODUCTID, QUANTITY, ORDERYEAR, TOTAL_BY_PROD, AVG_BY_PROD
FROM Sales.TOP_PRODUCTS(729)
WHERE ORDERYEAR = 2014;
GO

SELECT 
    CUSTOMERID,
    T2.SALESPERSON
    ORDER_DUE,
    TOTAL_SALES
FROM Sales.SalesOrderHeader AS T1
    INNER JOIN
    Sales.SALESPERSON_YEAR (2012) AS T2
ON T1.SalesPersonID = T2.SALESPERSON
WHERE T1.CustomerID = 29825;

--- TVF COM CTE

IF OBJECT_ID('SALES.TOTAL_BY_COUNTRY') IS NOT NULL DROP FUNCTION SALES.TOTAL_BY_COUNTRY; -- IMG21
GO

CREATE FUNCTION SALES.TOTAL_BY_COUNTRY

    (@COUNTRYID AS INT) RETURNS TABLE

AS 
RETURN
WITH CT AS (

        SELECT 
            T1.TERRITORYID, T1.[GROUP] AS REGION_NAME, COUNT(T2.SALESORDERID) AS QTD_ORDER,
            COALESCE(T2.SALESPERSONID, 0) AS SALESPERSON, YEAR(ORDERDATE) AS ORDER_YEAR,
            SUM(TOTALDUE) AS TOTAL_SALES
        FROM SALES.SALESTERRITORY AS T1
            INNER JOIN
            SALES.SALESORDERHEADER AS T2
        ON T1.TERRITORYID = T2.TERRITORYID
        GROUP BY T1.TERRITORYID, [GROUP], YEAR(ORDERDATE), SALESPERSONID
        HAVING T1.TERRITORYID = @COUNTRYID)

SELECT * FROM CT;
GO

SELECT TerritoryID, 
    QTD_ORDER, REGION_NAME, 
    SALESPERSON, ORDER_YEAR 
FROM Sales.TOTAL_BY_COUNTRY(1)
WHERE QTD_ORDER IN 
                (SELECT MAX(QTD_ORDER) 
                FROM Sales.TOTAL_BY_COUNTRY(1));

SELECT * FROM Sales.TOTAL_BY_COUNTRY(2)
WHERE QTD_ORDER = (
                    SELECT MAX(QTD_ORDER)
                    FROM Sales.TOTAL_BY_COUNTRY(2) AS ORDER_COUNTRY);
GO

SELECT
    T2.SalesOrderID, ProductID, 
    SUM(OrderQty) AS TOTAL_QTY, T3.TOTAL_SALES
FROM Sales.SalesOrderDetail AS T1
    INNER JOIN
    Sales.SalesOrderHeader AS T2
ON T1.SalesOrderID = T2.SalesOrderID
    INNER JOIN 
    Sales.TOTAL_BY_COUNTRY(2) AS T3
ON T2.TerritoryID = T3.TerritoryID
GROUP BY ProductID, T2.SalesOrderID, TOTAL_SALES
HAVING ProductID = 708;

WITH CTE_PROD AS ( 

    SELECT 
        T1.SALESORDERID, PRODUCTID,
        ORDERQTY, TERRITORYID
    FROM Sales.SalesOrderDetail AS T1
        INNER JOIN
        Sales.SalesOrderHeader AS T2
    ON T1.SalesOrderID = T2.SalesOrderID
)
SELECT PRODUCTID, SUM(ORDERQTY) AS TOTAL_QTY, T1.TERRITORYID, ORDER_YEAR
FROM CTE_PROD AS T1
    INNER JOIN
    Sales.TOTAL_BY_COUNTRY(2) AS T2
ON T1.TerritoryID = T2.TerritoryID
GROUP BY PRODUCTID, T1.TerritoryID, ORDER_YEAR
HAVING ProductID = 754 AND ORDER_YEAR BETWEEN 2011 AND 2015;

SELECT ProductID, (ListPrice * 1040) AS A, StandardCost FROM Production.Product WHERE ProductID = 754;

----------  OPERADOR APPLY ----------

-- OPERADOR DE TABELA QUE APLICA UMA NA OUTRA
-- É EXECUTADO NA PARTE LÓGICA DO PROCESSAMETO DA QUERY
-- TRÊS TIPOS: OUTER, CROSS E UMA FORMA IMPLÍCITA
-- CROSS APPLY POSSUI DOIS PASSOS NA EXECUÇÃO, DIFERENTE DO OUTER QUE SÃO TRÊS
-- OBSERVAÇÃO: CROSS JOIN E APPLY SÃO BEM SIMILARES EM SEUS RESULTADOS
-- O CONJUNTO DA DIREITA É APLICADO NA TABELA ESQUERDA LINHA A LINHA, DEPENDENDO DA CORRELAÇÃO
-- NO CROSS APPLY, COMPARAÇÕES SEM CORRESPONDÊNCIAS SÃO DESCARTADAS

-- TESTE CROSS JOIN E APPLY
-- AMBOS OS RESULTADOS SÃO EXATAMENTE IGUAIS

SELECT 
    DEPARTMENTID,
    [NAME] AS DEPART_NAME,
    T2.BusinessEntityID
FROM HumanResources.Department AS T1
CROSS JOIN
    HumanResources.Employee AS T2;

SELECT 
    DEPARTMENTID,
    [NAME] AS DEPART_NAME,
    T2.BusinessEntityID
FROM HumanResources.Department AS T1
CROSS APPLY
    HumanResources.Employee AS T2;

-- A DIFERENÇA ENTRE CROSS JOIN E APPLY
-- A TABELA INTERNA FILTRA O RESULTADO REFERENCIADO NA COLUNA CUSTOMERID DA EXTERNA
-- COMO A FUNÇÃO 'APLICA' UMA TABELA NA OUTRA, O FILTRO RETORNA OS 3 PEDIDOS MAIS RECENTES
SELECT
    T1.CUSTOMERID, T2.SALESORDERID, -- IMG24
    T2.SUBTOTAL, T2.ORDERDATE
FROM Sales.Customer AS T1 -- LEFT TABLE
    CROSS APPLY(
        SELECT TOP(3) 
            SALESORDERID, SALESPERSONID, 
            ORDERDATE, SUBTOTAL
        FROM Sales.SalesOrderHeader AS T
        WHERE T1.CustomerID = T.CustomerID -- RIGHT TABLE
        ORDER BY OrderDate DESC) AS T2
WHERE T1.CUSTOMERID = 29497;

-- SE HOUVER NECESSIDADE DE UTILIZAR APPLY E RETORNAR VALORES NULOS, UTILIZE OUTER
-- COMO UMA DAS ETAPAS DO OUTER APPLY É RETORNAR OS VALORES NÃO CORRESPONDIDOS, PODEMOS VISUALIZAR OS VALORES NULOS
-- É BEM SIMILAR AO OUTER JOIN
SELECT
    T1.BUSINESSENTITYID, -- IMG25
    T1.FIRSTNAME, T2.ACCOUNTNUMBER
FROM Person.Person AS T1
    OUTER APPLY(
        SELECT
            T.CUSTOMERID, T.PERSONID,
            T.ACCOUNTNUMBER
        FROM Sales.Customer AS T
        WHERE T1.BusinessEntityID = T.CustomerID
    ) AS T2
ORDER BY T2.CustomerID ASC;

-- UMA EXCELENTE UTILIZAÇÃO DO OUTER APPLY

IF OBJECT_ID(N'SALES.LAST_ORDER') IS NOT NULL DROP FUNCTION SALES.LAST_ORDER; -- IMG26
GO

CREATE FUNCTION SALES.LAST_ORDER
    (@CUSTID AS INT,
    @TOPORDER AS INT)    
RETURNS TABLE
AS 
    RETURN
        SELECT
            T1.CUSTOMERID, T1.PERSONID, T4.FIRSTNAME,
            T4.LASTNAME, T2.SALESORDERID, T2.SALESPERSONID,
            CAST(T2.ORDERDATE AS DATE) AS ORDERDATE, T2.SUBTOTAL
        FROM SALES.CUSTOMER AS T1
            CROSS APPLY (
                SELECT TOP(@TOPORDER)
                    T.CUSTOMERID, T.SALESORDERID, T.ORDERDATE,
                    T.SALESPERSONID, T.SUBTOTAL
                FROM Sales.SalesOrderHeader AS T
                WHERE T1.CustomerID = T.CustomerID
                ORDER BY OrderDate DESC) AS T2
INNER JOIN Person.Person AS T4
ON T1.PersonID = T4.BusinessEntityID
WHERE T1.CustomerID = @CUSTID;
GO

SELECT 
    CUSTOMERID,
    FIRSTNAME,
    LASTNAME,
    ORDERDATE,
    SUBTOTAL    
FROM Sales.LAST_ORDER(29825, 3) AS LAST_ORDER_CUST;


-- EXEMPLO APLICANDO UMA TABELA EM UMA FUNÇÃO COM CROSS-APPLY

IF OBJECT_ID('HUMANRESOURCES.TOP_RATES') IS NOT NULL DROP FUNCTION HUMANRESOURCES.TOP_RATES;
GO

CREATE FUNCTION HUMANRESOURCES.TOP_RATES -- IMG26
    (@EMPID AS INT,
    @TOPRATE AS INT) 
RETURNS TABLE
AS 
    RETURN
        SELECT 
            T1.BUSINESSENTITYID, T1.LOGINID, T1.JOBTITLE,
            T1.HIREDATE, T2.RATE AS SALARY, T2.PAYFREQUENCY AS FREQUENCY
        FROM HumanResources.Employee AS T1
            CROSS APPLY(
                SELECT TOP(@TOPRATE)
                    T.BUSINESSENTITYID, RATE, T.PayFrequency
                FROM HumanResources.EmployeePayHistory AS T
                WHERE T1.BUSINESSENTITYID = T.BUSINESSENTITYID
            ) AS T2
WHERE T1.BusinessEntityID = @EMPID;
GO

SELECT
    T1.BUSINESSENTITYID, FIRSTNAME, LASTNAME,
    T2.SALARY, T2.FREQUENCY
FROM Person.Person AS T1
    CROSS APPLY
    HumanResources.TOP_RATES(8, 1) AS T2
WHERE T1.BusinessEntityID = T2.BusinessEntityID;
GO

-- APPLY IMPLÍCITO
SELECT BusinessEntityID 
FROM HumanResources.EmployeePayHistory
GROUP BY BusinessEntityID
HAVING COUNT(RATE) >=3;

SELECT
    T1.BUSINESSENTITYID,
    (SELECT
        COUNT(SALARY)
    FROM HumanResources.TOP_RATES(T1.BusinessEntityID, 3)) AS CNT_SALARY
FROM HumanResources.Employee AS T1
GO

--  APPLY AVANÇADO
-- OTIMIZAÇÃO PARA TABELAS DE ALTA E BAIXA DENSIDADE
-- CONCEITO DE POC 
        -- PARTITION (CUSTID)
        -- ORDERING (ORDERID DESC, ORDERDATE DESC)
        -- COVERAGE (EMPID)

-- SÃO AS PRINCIPAIS COLUNAS DA TABELA DO BANCO

CREATE INDEX  IDX_POC ON SALES.SalesOrderHeader (CUSTOMERID, ORDERDATE DESC, SALESORDERID DESC) INCLUDE (SALESPERSONID);
GO

-- LOW DENSITY = 1KK CUST X 10 ==> 10KK ORDER -- SEEK READS NÃO SERIA ACONSELHÁVEL, O MELHOR É SCAN
    -- COMO EXISTEM 1KK DE CLIENTES, HAVERIAM EM TEORIA, 1KK DE PARTIÇÕES, O QUE SERA MUITO CUSTOSO PARA UM SEEK.
    -- SEEK P/ CUST --> 3KK RANDOM READS
    -- SCAN --> 30K SEQUENTIAL READS

-- HIGH DENSITY = 10 CUST X 1KK ==> 10KK ORDER
    -- SEEK P/ CUST  30
    -- SCAN 30K SEQUENTIAL READS

-- ESSA TÉCNICA SÓ FUNCIONA QUANDO HÁ CONDIÇÕES PARA O 'MODELO POC'.


WITH IDXPOC AS (
SELECT
    CUSTOMERID,
    SALESORDERID,
    ORDERDATE,
    SALESPERSONID,
    ROW_NUMBER() OVER(PARTITION BY CUSTOMERID
                        ORDER BY ORDERDATE DESC, SALESORDERID DESC) AS ROWNUM
FROM Sales.SalesOrderHeader)
SELECT    
    CUSTOMERID,
    SALESORDERID,
    ORDERDATE,
    SALESPERSONID FROM IDXPOC
WHERE ROWNUM <=3;

-- QUERO APLICAR ESSA LÓGICA DE LEITURA NO CROSS APPLY 
SELECT TOP(3)
    SALESORDERID,
    ORDERDATE,
    SALESPERSONID
FROM Sales.SalesOrderHeader 
WHERE CUSTOMERID = 11000
ORDER BY ORDERDATE DESC, SalesOrderID DESC;

-- APLICANDO EM UMA OPERAÇÃO DE APPLY
SELECT T1.CustomerID, T1.AccountNumber, T2.*
FROM Sales.Customer AS T1
    CROSS APPLY (SELECT TOP(3)
                    SALESORDERID,
                    ORDERDATE,
                    SALESPERSONID
                FROM Sales.SalesOrderHeader  AS T
                WHERE T.CustomerID = T1.CustomerID
                ORDER BY ORDERDATE DESC, SalesOrderID DESC) AS T2;

-- OTIMIZANDO PARTITON TABLE COM APPLY

SELECT MAX(ORDERDATE) FROM Sales.SalesOrderHeader;

SELECT MIN(ORDERDATE) FROM Sales.SalesOrderHeader;

-- COM O CROSS JOIN, NÃO PODEMOS REFERENCIAR ELEMENTOS DA OUTRA TABELA
-- -- VEJA QUE NÃO É POSSÍVEL IGUALAR AS DUAS QUERIES POIS A COLUNA T1.CUSTOMERID NÃO É REFERENCIÁVEL NA QUERY INTERNA
-- SELECT
--     T1.CUSTOMERID,
--     T2.SALESORDERID,
--     T2.SUBTOTAL,
--     T2.ORDERDATE
-- FROM Sales.Customer AS T1 
--     CROSS JOIN(
--         SELECT TOP(3) SALESORDERID, SALESPERSONID, ORDERDATE, SUBTOTAL
--         FROM Sales.SalesOrderHeader AS T
--         WHERE T1.CustomerID = T.CustomerID
--         ORDER BY OrderDate DESC) AS T2;